OOP or Object Oriented Programming is a programming style or paradigms, this means that it is like a manner of coding and set up your programs and instructions in your mind.


The reason why oop came to life is that it solves the major problems with the other programming pridigms that were befor it (procedural).

The procedural programming paridigm is one of the most used styles of programming, it basicly consist on seperating the whole program into two main blocks, data and instructions. This is very helpful but the existence of two independent block like this leads to organization and implementation security risks, since every varibale is global, or just owned by one function.

So the oop solved this problem, this time not by breaking the entire program into two parts but by destructuring the program into object which can contain several varaibles called propreties and several functions called methods, so this idea of breaking your program into chapters modelized by objects increases the implementation security of the code base, and also gives the programmer a good organization based manner of coding.



This principle is called the encapsulation, it groups all the related data and functions into an object. This is the first of the four pillar of oop.


The second pillar is inheritence, and this basicly says that we can build an object modal and make other objects copies of this modal, then we says the the produced object inherited from the modal project. This will help us to avoid repetitive code, and respect the dry principle.


Abstraction is also another pillar of oop, this consist of the fact that the global overview of an object (which is called the interface) is usally simplified to make the interaction between the programmer and this peace of data easyer. This is done by hiding the details, like some propreties that are not ment to be indexed and used just in the methods, or hiding some function that are not ment to be invoked by the user, but just by other more meaningfull methods that will be eventually the ones that will be called.




Polymorphism is the last oop piller. Poly means many, morphism means forms, so polymorphism means many forms, and this basicly refers to the fact that an object can have many forms even if it has the same modal or schemma with another one. This is very useful if we want to handel multiple cases which are similar but not identical, like imaging html elements, to render everyone of them in the procedural way we will have to write a very long and nasty switch case statement, but with oop, we can just at to the modal a render method and call it from every entity out there.




From here and out we will be looking to the practical oop using javaScript.



Factory function: this notion refers to a function that returns an object, which is not availible before, so this function will create it and then set it key value pairs, lastly it will return it.

Constructor: this notion refers to a function that modifies an existing object by refrence, this means that when we call the constructor function the this keyword will point to an existing object, this is why we use constructor functions after the keyword new, which will basiclly create an instence of object and points the this pointer to that object in the current scope.



So with that been said we know now that every object has been created with a function, and we call this function the object constructure function, and we can access it just by refrecing it by the . notation after the objectname, exmple: user.constructor.

The default constructor function in javascript, is the Object built in function, this function is the one that creats the object that we declare letteraly like for exemple:

	let user = {
		username : "name",
		id: "21"
	};
	  
When we write this, the built in Object constructor function will be invoked in order to create this object.

So behind the scenes, that peace of code will be interpreted like this:

	let user = new Object(username: "name", id:"21");
	
-----------------------------------------------------------------------
Notes:	 in javascript any data types diffrent then primitives are objects, so arrays, functions and objects are just plain objects
-----------------------------------------------------------------------

	
Data representation in javascript:

in javascript we have only two types of data representation, we have premitives (numbers, strings, booleans, undefined, null), and refrence types (objects, functions, arrays) or just objects.


And the diffrence is that when we assign to a variable a primitive  data (like a string or so), we are assigning it value to. But when we assign a variable an object, an array or a function, we are assigning it address in the memory.

let see this in practice: 

	let x = 10;
	let y = x;
	
	x++;
	
	console.log(x); // x = 11;
	console.log(y); // y = 10;
	
The reason why the y variable is returned as a 10 number, is that when we've done the assignement of x into it, we've basicly copied the value of x into it. So y and x are completely independent.


When we assign by refrence:

	let x = {value: 10};
	let y = x;
	
	x.value++;
	
	console.log(x.value); // x.value = 11;
	console.log(y.value); // y.value = 11;
	
	
The reason why the y variable is now containing the value proprety set to 11, is that when we've done the assignement of the x variable into it, we've basicly saved into y the address of the object stored in x.

So now, to manipulate the same object in memory we have to paths, we can go either by x or y. Now y and x are not independent.

----------------------------------------------------------------------

How to make some propreties or methods within an object private to simplify the object outer interface, and create a greate layer of abstraction?.


So we do that by setting the members that we want to hide as local viariabls within the object, so as these members are just accessible by the other members of the same object. Like this, we reduce the the interface  complexity of that object, and also we will end up with a better code since fewer members can be modified by the user.

Practice: 

Imagine that we have this object and we want to make the user.isLoggedin proprety private.


	function User(isLoggedin) {
		this.username : "name",
		this.hash : "hssa03",
		
		this.isLoggedin, // === this.isLoggedin : isLoggedin
		
		
		this.forceLoggin : function(isUserLoggedin) {
			if (!isUserLoggedin) redirect('/login');
		},		
		
		this.skipLoggin  : function(isUserloggedin) {
			if (isUserLoggedin) redirect('/home');
		},
		
	};
	
	let user = new User(false);
	
	
	
With this implementation, the user of the client will be able to touch the user.isLoggedin proprety and with that skip the login phase which can ruine the activity of our web app.


So to make this proprety private or in other words hidden for the user, we do this:


	function User(isLoggedin) {
		this.username : "name",
		this.hash : "hssa03",
		
		let isLoggedin = isLoggedin,
		
		this.forceLoggin : function(isUserLoggedin) {
			if (!isUserLoggedin) redirect('/login');
		},		
		
		this.skipLoggin  : function(isUserloggedin) {
			if (isUserLoggedin) redirect('/home');
		},
		
	};
	
	let user = new User(false);
	
	
So now we have more abstaction and security layers.



----------------------------------------------------------------------

How to know if a variable is an object or a primitve?

we can basicly use the typeOf() function,


What is a prototype?

In javascript, every object, or any data container with a typeOf equal to object has a proprety called __proto__, and has a prototype the can be accessed by the entity modal object name, like if we have a string we can access the prototype object with String.prototype.

So a prototype is an object which behaves  like a librery of mehods related to some object based entity, this object is unique for all the the entity that are based on the same object modal, so for all string, we have one exemple, and the __proto__ proprety in each one of these string is a refrence (pointer) to the prototype proprety in the modal object, 

So if we have multiple strings and we want to add to them  a custom method, we don't need to go to each one and append it to it, we can just append it to the modal object prototype object, and we acheive that by doing this, String.prototype.custom_method= function()



So to recap, a data type prototype is a schemma saved as an object in memory, and every instence of that data type contains the __proto__ proprety which is basicly a pointer to the data type prototype.

---------------------------------------------------------------------
  


A project idea that can help you to understand better or perfectly the oop paradigm, this idea consiste on taking a procedural code base implementation and turn it into a oop implementation.

For exemple: I will take the singleLinkedList library that I wrote in pascal (procedural) and turn it into a javascript library (oop). With this I will learn the benefit of using the classes and the inheretence and the abstration principles, and surpass the diffecutly imposed when passing the singleLinkedList pointers, and also reduce the arguments count for the function that are manipulating the list structure or object ;) .






